import sys
import os
sys.path.append(os.environ['QMIPATH'])
from Includes.common_classes import *
from Includes.selections import *
from Includes.ntuples import *
from Includes.variables import *
from Includes.common_constants import *
from Includes.functions import *
from Includes.VARDICT import VARDICT


import argparse
parser = argparse.ArgumentParser(description='Signal only Fit')
parser.add_argument('--index', type=int, default=1, help='Index of the toy MC')
parser.add_argument('--gpu', type=str, default='0', help='GPU to use')

parser.print_help()
args = parser.parse_args()
index=args.index
update = True

import os
os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID"   # see issue #152
os.environ["CUDA_VISIBLE_DEVICES"]=args.gpu

from importlib.machinery import SourceFileLoader
import uproot as up
import numpy as np
import time
import iminuit
import sys
import tensorflow as tf
tf.get_logger().setLevel('INFO')

time1 = time.time()

from tfpcbpggsz.core import *
from tfpcbpggsz.masspdfs import *
from tfpcbpggsz.amp import *

Kspipi = PyD0ToKSpipi2018()
Kspipi.init()
mc_path = '/shared/scratch/pc24403/amp_ampgen_new'

def get_mass(p1,p2):
    return ((p1[:,0]+p2[:,0])**2 - (p1[:,1]+p2[:,1])**2 - (p1[:,2]+p2[:,2])**2 - (p1[:,3]+p2[:,3])**2)

def get_p4(decay="b2dpi", cut='', index=index):

    file_name = ''
    branch_names = []
    if cut == 'int':
        file_name = f'/software/pc24403/PCBPGGSZ/Int/weighted_{decay}.root:DalitzEventList'
        branch_names = ["_1_K0S0_E", "_1_K0S0_Px", "_1_K0S0_Py", "_1_K0S0_Pz",
                         "_2_pi#_E", "_2_pi#_Px", "_2_pi#_Py", "_2_pi#_Pz",
                         "_3_pi~_E", "_3_pi~_Px", "_3_pi~_Py", "_3_pi~_Pz"]
    
    elif decay.split('_')[0] == 'b2dk' or decay.split('_')[0] == 'b2dpi':
        branch_names = ["_1_K0S0_E", "_1_K0S0_Px", "_1_K0S0_Py", "_1_K0S0_Pz",
                         "_2_pi#_E", "_2_pi#_Px", "_2_pi#_Py", "_2_pi#_Pz",
                         "_3_pi~_E", "_3_pi~_Px", "_3_pi~_Py", "_3_pi~_Pz"]
        if cut == 'p':
            file_name = f'/shared/scratch/pc24403/1x/{decay}_test_{index}.root:Bplus_DalitzEventList'
        else:
            file_name = f'/shared/scratch/pc24403/1x/{decay}_test_{index}.root:Bminus_DalitzEventList'

    tree = up.open(file_name)
  # Load the branches as arrays
    charge = '(Bac_ID>0) '
    if cut == 'm':
        charge = '(Bac_ID<0)  '
       
    array = tree.arrays(branch_names, charge)
    _p1 = np.asarray([array["_1_K0S0_E"], array["_1_K0S0_Px"], array["_1_K0S0_Py"], array["_1_K0S0_Pz"]])
    _p2 = np.asarray([array["_2_pi#_E"], array["_2_pi#_Px"], array["_2_pi#_Py"], array["_2_pi#_Pz"]])
    _p3 = np.asarray([array["_3_pi~_E"], array["_3_pi~_Px"], array["_3_pi~_Py"], array["_3_pi~_Pz"]])
    
    # convert 4*1000 into a vectot<double>
    p1 = np.transpose(_p1)
    p2 = np.transpose(_p2)
    p3 = np.transpose(_p3)

    p1bar = np.hstack((p1[:, :1], np.negative(p1[:, 1:])))
    p2bar = np.hstack((p2[:, :1], np.negative(p2[:, 1:])))
    p3bar = np.hstack((p3[:, :1], np.negative(p3[:, 1:])))



    return p1, p2, p3, p1bar, p2bar, p3bar

def load_int_amp(args):
    p1, p2, p3 = args

    return Kspipi.AMP(p1.tolist(), p2.tolist(), p3.tolist())

def getAmp(decay='b2dpi', cut='int', index=index):

    start_time = time.time()
    p1, p2, p3, p1bar, p2bar, p3bar = get_p4(decay=decay, cut=cut, index=index)
    amplitude = []
    amplitudeBar = []

    p1_np = np.array(p1)
    p2_np = np.array(p2)
    p3_np = np.array(p3)
    p1bar_np = np.array(p1bar)
    p2bar_np = np.array(p2bar)
    p3bar_np = np.array(p3bar)

    data = [(p1_np[i], p2_np[i], p3_np[i]) for i in range(len(p1_np))]
    amplitude = [load_int_amp(args) for args in data]
    data_bar = [(p1bar_np[i], p3bar_np[i], p2bar_np[i]) for i in range(len(p1bar_np))]
    amplitudeBar = [load_int_amp(args) for args in data_bar]
    
    end_time = time.time()
    print(f'Amplitude for {decay} loaded in {end_time-start_time} seconds')
    amplitude = np.array(amplitude)
    amplitudeBar = np.negative(np.array(amplitudeBar))

    return amplitude, amplitudeBar
    
def get_p4_v2(decay="b2dpi", cut='', index=index, comp='sig'):

    file_name = ''
    branch_names = []
    if cut == 'int':
        file_name = f'/software/pc24403/PCBPGGSZ/Int/weighted_{decay}.root:DalitzEventList'
        branch_names = ["_1_K0S0_E", "_1_K0S0_Px", "_1_K0S0_Py", "_1_K0S0_Pz",
                         "_2_pi#_E", "_2_pi#_Px", "_2_pi#_Py", "_2_pi#_Pz",
                         "_3_pi~_E", "_3_pi~_Px", "_3_pi~_Py", "_3_pi~_Pz"]
    
    elif decay.split('_')[0] == 'b2dk' or decay.split('_')[0] == 'b2dpi':
        branch_names = ["_1_K0S0_E", "_1_K0S0_Px", "_1_K0S0_Py", "_1_K0S0_Pz",
                         "_2_pi#_E", "_2_pi#_Px", "_2_pi#_Py", "_2_pi#_Pz",
                         "_3_pi~_E", "_3_pi~_Px", "_3_pi~_Py", "_3_pi~_Pz", "B_M"]
        if cut == 'p':
            file_name = f'/shared/scratch/pc24403/1x/{decay}_test_{index}.root:Bplus_DalitzEventList'
        else:
            file_name = f'/shared/scratch/pc24403/1x/{decay}_test_{index}.root:Bminus_DalitzEventList'

    tree = up.open(file_name)
  # Load the branches as arrays
    charge = '(Bac_ID>0)  '
    if cut == 'm':
        charge = '(Bac_ID<0)  '
    
    array = tree.arrays(branch_names, charge)
       

    _p1 = np.asarray([array["_1_K0S0_E"], array["_1_K0S0_Px"], array["_1_K0S0_Py"], array["_1_K0S0_Pz"]])
    _p2 = np.asarray([array["_2_pi#_E"], array["_2_pi#_Px"], array["_2_pi#_Py"], array["_2_pi#_Pz"]])
    _p3 = np.asarray([array["_3_pi~_E"], array["_3_pi~_Px"], array["_3_pi~_Py"], array["_3_pi~_Pz"]])
    
    # convert 4*1000 into a vectot<double>
    p1 = np.transpose(_p1)
    p2 = np.transpose(_p2)
    p3 = np.transpose(_p3)

    p1bar = np.hstack((p1[:, :1], np.negative(p1[:, 1:])))
    p2bar = np.hstack((p2[:, :1], np.negative(p2[:, 1:])))
    p3bar = np.hstack((p3[:, :1], np.negative(p3[:, 1:])))

    B_M = np.zeros(len(p1))
    if cut != 'int':
        
        B_M = np.asarray([array["B_M"]])


    return p1, p2, p3, p1bar, p2bar, p3bar, B_M


def getMass(decay='b2dpi', cut='int', index=index):


    p1, p2, p3, p1bar, p2bar, p3bar = get_p4(decay=decay, cut=cut, index=index)

    p1_np = np.array(p1)
    p2_np = np.array(p2)
    p3_np = np.array(p3)

    s12 = get_mass(p1_np, p2_np)
    s13 = get_mass(p1_np, p3_np)

    return s12, s13

def getMass_v2(decay='b2dpi', cut='int', comp='sig', index=index):

    p1, p2, p3, p1bar, p2bar, p3bar, B_M = get_p4_v2(decay=decay, cut=cut, comp=comp, index=index)


    p1_np = np.array(p1)
    p2_np = np.array(p2)
    p3_np = np.array(p3)


    s12 = get_mass(p1_np, p2_np)
    s13 = get_mass(p1_np, p3_np)

    return s12, s13, B_M



def scanner(m, scan_range=1, size=50):
    pts = {}
    for i in range(0, 6):
        for j in range(i + 1, 6):
            a = m.parameters[i]
            b = m.parameters[j]
            a_err = m.errors[i]
            b_err = m.errors[j]
            a_val = m.values[i]
            b_val = m.values[j]
            x0, x1 = i, j  # Assign x0 and x1 for key naming
            pts[f"{x0}_{x1}"] = m.contour(
                a, b,
                bound=[
                    [a_val - scan_range * a_err, a_val + scan_range * a_err],
                    [b_val - scan_range * b_err, b_val + scan_range * b_err]
                ],
                size=size
            )
    return pts


config_mass_shape_output = SourceFileLoader('config_mass_shape_output', '/shared/scratch/pc24403/sim_fit/ana/%s'%('config_mass_shape_output_1.py')).load_module()

varDict = config_mass_shape_output.getconfig()




pdfs_data = {}
s12_data = {}
s13_data = {}
Bu_M = {}
mass_pdfs = {}
for decay in ['b2dpi_LL', 'b2dpi_DD', 'b2dk_LL', 'b2dk_DD']:
    for charge in ['p', 'm']:
        new_decay = decay + '_'+ charge
        print('--- INFO: Building function for %s...'%new_decay)
        s12_data[new_decay], s13_data[new_decay], Bu_M[new_decay] = getMass_v2(decay, charge, index)
        Bu_M[new_decay] = tf.cast(Bu_M[new_decay], tf.float64)
        pdfs_data[new_decay] = preparePdf_data(varDict, decay)

comps = ['sig', 'misid', 'comb', 'low', 'low_misID', 'low_Bs2DKPi']
for decay in ['b2dpi_LL', 'b2dpi_DD', 'b2dk_LL', 'b2dk_DD']:
    for charge in ['p', 'm']:
        new_decay = decay + '_'+ charge
        mass_pdfs[new_decay] = {}
        for comp in comps:
            if decay.split('_')[0] == 'b2dpi' and (comp == 'low_Bs2DKPi' or comp == 'low_misID'): continue
            mass_pdfs[new_decay][comp] = pdfs_data[new_decay][comp](Bu_M[new_decay])
time2 = time.time()

eff_dic = {}
eff={}
eff_misid={}
eff_low={}
eff_comb_a={}
eff_comb_abar={}
print('INFO: Calculate efficiency...')
for decay in ['b2dpi_LL', 'b2dpi_DD', 'b2dk_LL', 'b2dk_DD']:
    for charge in ['p', 'm']:
        new_decay = decay + '_'+ charge
        eff_dic[new_decay] = {}
        eff_dic[new_decay]['sig'] = eff_fun(dalitz_transform(s12_data[new_decay], s13_data[new_decay]), charge, decay)
        eff_dic[new_decay]['comb_a'] = eff_fun(dalitz_transform(s12_data[new_decay], s13_data[new_decay]), 'm', decay.replace('dk', 'dpi'))
        eff_dic[new_decay]['comb_abar'] = eff_fun(dalitz_transform(s12_data[new_decay], s13_data[new_decay]), 'p', decay.replace('dk', 'dpi'))
        eff_dic[new_decay]['low'] = eff_fun(dalitz_transform(s12_data[new_decay], s13_data[new_decay]), charge, decay.replace('dk', 'dpi'))
        if decay.split('_')[0] == 'b2dpi':
            eff_dic[new_decay]['misid'] = eff_fun(dalitz_transform(s12_data[new_decay], s13_data[new_decay]), charge, decay.replace('dpi', 'dk'))
        elif decay.split('_')[0] == 'b2dk':
            eff_dic[new_decay]['misid'] = eff_fun(dalitz_transform(s12_data[new_decay], s13_data[new_decay]), charge, decay.replace('dk', 'dpi'))     

print('INFO: mass Function loaded...')


frac_bkg = {}
if update == True:
    print('INFO: Updating Log...')
    comp_tag = {'sig': 1, 'comb': 2, 'misid': 3, 'low': 4, 'low_misID': 5, 'low_Bs2DKPi': 6}
    for decay in ['DPi_KsPiPi_LL', 'DPi_KsPiPi_DD', 'DK_KsPiPi_LL', 'DK_KsPiPi_DD']:
        bkg=0
        sig=0
        new_decay = decay
        if decay.split('_')[0] == 'DK':
            new_decay = 'b2dk_'+decay.split('_')[2]
        elif decay.split('_')[0] == 'DPi':
            new_decay = 'b2dpi_'+decay.split('_')[2]

        for charge in ['p', 'm']:
            Bcharge = 'Bplus'
            charge_flag = '(Bac_ID>0)  '
            if charge == 'm':
                Bcharge = 'Bminus'
                charge_flag = '(Bac_ID<0)  '
            file_name = f'/shared/scratch/pc24403/1x/{new_decay}_test_{index}.root:{Bcharge}_DalitzEventList'
            tree = up.open(file_name)
            for comp in comp_tag:
                array = tree.arrays('tagmode',f'(B_M>5080) & (tagmode==%d) & {charge_flag}'%comp_tag[comp])
                varDict[f'n_{comp}_{decay}_{charge}'] = tf.cast(len(array), tf.float64)
                if decay.split('_')[0] == 'DPi' and (comp == 'low_Bs2DKPi' or comp == 'low_misID'): continue
                mass_pdfs[new_decay+'_'+charge][comp] = mass_pdfs[new_decay+'_'+charge][comp]*varDict[f'n_{comp}_{decay}_{charge}']
                print(f'n_{comp}_{decay}_{charge} = {len(array)}')


print(f'frac_bkg = {frac_bkg}')

print_yields = False
sig_yield = {}


frac_DD_dic = {}

for decay in ['b2dpi_LL', 'b2dpi_DD', 'b2dk_LL', 'b2dk_DD']:
    for charge in ['p', 'm']:
        Bcharge = 'Bplus'
        charge_flag = '(Bac_ID>0)  & (tagmode==2)'
        if charge == 'm':
            Bcharge = 'Bminus'
            charge_flag = '(Bac_ID<0)  & (tagmode==2)'
        file_name = f'/shared/scratch/pc24403/1x/{decay}_test_{index}.root:{Bcharge}_DalitzEventList'
        tree = up.open(file_name)
        array_flat = tree.arrays(f'tagmode',f'(B_M>5080) & (flav==9) & {charge_flag}')
        array_dd = tree.arrays(f'tagmode',f'(B_M>5080) & (flav!=9) & {charge_flag}')
        frac_DD_dic[decay+'_'+charge] = tf.cast(len(array_dd)/(len(array_dd)+len(array_flat)), tf.float64)
        
print(f'frac_DD = {frac_DD_dic}')



logpath = './'
if os.path.exists(logpath) == False:
    os.mkdir(logpath)

#Can be merged
amp_Data={}
amp_MC={}
ampbar_Data={}
ampbar_MC={}
normA={}
normAbar={}
normalisationCrossTerms={}
print('INFO: Loading amplitudes...')
for decay in ['b2dpi_LL', 'b2dpi_DD']:
    for charge in ['p', 'm']:
        amp_MC[decay+'_'+charge], ampbar_MC[decay+'_'+charge] = np.load(mc_path + '/Int_%s_%s_amp.npy'%(decay, charge)), np.load(mc_path + '/Int_%s_%s_ampbar.npy'%(decay, charge))
        if decay.split('_')[0] == 'b2dk':
            amp_MC[decay.replace('dk', 'dpi')+'_'+charge], ampbar_MC[decay.replace('dk', 'dpi')+'_'+charge] = np.load(mc_path + '/Int_%s_%s_amp.npy'%(decay.replace('dk', 'dpi'), charge)), np.load(mc_path + '/Int_%s_%s_ampbar.npy'%(decay.replace('dk', 'dpi'), charge))
        else:
            amp_MC[decay.replace('dpi', 'dk')+'_'+charge], ampbar_MC[decay.replace('dpi', 'dk')+'_'+charge] = np.load(mc_path + '/Int_%s_%s_amp.npy'%(decay.replace('dpi', 'dk'), charge)), np.load(mc_path + '/Int_%s_%s_ampbar.npy'%(decay.replace('dpi', 'dk'), charge))
            
for decay in ['b2dk_LL', 'b2dk_DD', 'b2dpi_LL', 'b2dpi_DD']: 
    for charge in ['p', 'm']:
        amp_Data[decay+'_'+charge], ampbar_Data[decay+'_'+charge] = getAmp(decay, charge, index=index)

        normA[decay+'_'+charge] = Normalisation(amp_MC, ampbar_MC, decay+'_'+charge)
        #normA[decay+'_'+charge].debug()
        normA[decay+ '_' +charge].initialise()
        normA[decay+ '_' +charge].initialise_misid()
        #print('INFO: Amplitudes for %s_%s loaded...'%(decay, charge))

time3 = time.time()




@tf.function
def prod_nll(x, decay, frac=False):
    """
    Calculates the negative log-likelihood for either decays.

    Args:
        x: Input parameters for the calculation.
        decay: The type of decay ('b2dk_DD' or 'b2dk_LL').

    Returns:
        The negative log-likelihood value.
    """
    
    # Data loading (common for both decays)
    DecayNLL = DecayNLLCalculator(amp_data=amp_Data, ampbar_data=ampbar_Data, normalisations=normA, mass_pdfs=mass_pdfs,fracDD=frac_DD_dic, eff_arr=eff_dic, params=x, name=decay)
    DecayNLL.initialise()
    nll = 0
    if frac==False:
        nll = DecayNLL._nll[decay + '_p']+DecayNLL._nll[decay + '_m']


    return nll



@tf.function
def nll(x):
    return  prod_nll(x, decay='b2dk_LL') + prod_nll(x, decay='b2dk_DD') + prod_nll(x, decay='b2dpi_LL') + prod_nll(x, decay='b2dpi_DD')


@tf.function
def neg_like_and_gradient(parms):
    return tfp.math.value_and_gradient(nll, parms)

#Val = tf.Variable([0., 0., 0., 0., 0., 0., varDict['n_sig_DK_KsPiPi_DD'],  varDict['n_comb_DK_KsPiPi_DD'], varDict['n_low_DK_KsPiPi_DD'], varDict['n_sig_DPi_KsPiPi_DD'], varDict['n_comb_DPi_KsPiPi_DD'], varDict['n_low_DPi_KsPiPi_DD'], varDict['n_sig_DK_KsPiPi_LL'],  varDict['n_comb_DK_KsPiPi_LL'], varDict['n_low_DK_KsPiPi_LL'], varDict['n_sig_DPi_KsPiPi_LL'], varDict['n_comb_DPi_KsPiPi_LL'], varDict['n_low_DPi_KsPiPi_LL']], shape=(18), dtype=tf.float64)
if False:
    Val = tf.Variable(np.zeros(4), shape=(4), dtype=tf.float64)


# optimization
    optim_results = tfp.optimizer.bfgs_minimize(
        neg_like_and_gradient, Val, tolerance=1e-8)

    est_params = optim_results.position.numpy()
    est_serr = np.sqrt(np.diagonal(optim_results.inverse_hessian_estimate.numpy()))
    print("Estimated parameters: ", est_params)
    print("Estimated standard errors: ", est_serr)
    fit_results = {'est_params': est_params, 'est_serr': est_serr}
    with open(f'{logpath}/simfit_output_{index}.npy', 'wb') as f:
        np.save(f, fit_results)

x = [0., 0., 0., 0., 0., 0.]
#x = [0., 0., 0., 0.]

m = iminuit.Minuit(nll, x)
# Minuit(least_squares_np, (5, 5), name=("a", "b"))
# m.limits = [(0, None), (0, 10)]
mg = m.migrad()
##mg = m.scipy()
#
## Perform the scan
#if False:
#  contours = scanner(mg, 5, 45)
#  np.save('contours.npy', contours)
#
#
with open(f'{logpath}/simfit_output_{index}.txt', 'w') as f:
    print(mg, file=f)
    means = mg.values
    errors = mg.errors
#    print("Means", means['x0'], means['x1'], means['x2'], means['x3'], file=f)
#    print("Errors", errors['x0'], errors['x1'], errors['x2'], errors['x3'], file=f)
    print("Means", means['x0'], means['x1'], means['x2'], means['x3'], means['x4'], means['x5'], file=f)
    print("Errors", errors['x0'], errors['x1'], errors['x2'], errors['x3'], errors['x4'], errors['x5'], file=f)


time4 = time.time()
print(f'Mass builder finished in {time2-time1} seconds')
print(f'Amplitude builder finished in {time3-time2} seconds')
print(f'Fit finished in {time4-time3} seconds')
print(f'Total time: {time4-time1} seconds')


shared_parameters = {
    "signal_mean_DK": [
        ["CB2DK_KSPIPI_DD", "DK_Kspipi", "cruij_m0"  ],
        ["CB2DK_KSPIPI_DD", "DK_Kspipi", "gauss_mean"],
        # ["CB2DK_KSKK_DD", "DK_Kspipi", "cruij_m0"  ],
        # ["CB2DK_KSKK_DD", "DK_Kspipi", "gauss_mean"],
        # ["CB2DK_KSPIPI_LL", "DK_Kspipi", "cruij_m0"  ],
        # ["CB2DK_KSPIPI_LL", "DK_Kspipi", "gauss_mean"],
        # ["CB2DK_KSKK_LL", "DK_Kspipi", "cruij_m0"  ],
        # ["CB2DK_KSKK_LL", "DK_Kspipi", "gauss_mean"],
    ],
    "signal_mean_Dpi": [
        ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "cruij_m0"  ],
        ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "gauss_mean"],
        # ["CB2DPI_KSKK_DD", "Dpi_Kspipi", "cruij_m0"  ],
        # ["CB2DPI_KSKK_DD", "Dpi_Kspipi", "gauss_mean"],
        # ["CB2DPI_KSPIPI_LL", "Dpi_Kspipi", "cruij_m0"  ],
        # ["CB2DPI_KSPIPI_LL", "Dpi_Kspipi", "gauss_mean"],
        # ["CB2DPI_KSKK_LL", "Dpi_Kspipi", "cruij_m0"  ],
        # ["CB2DPI_KSKK_LL", "Dpi_Kspipi", "gauss_mean"],
    ],
    "signal_width_DK_DD": [
        ["CB2DK_KSPIPI_DD", "DK_Kspipi", "cruij_sigmaL"  ],
        ["CB2DK_KSPIPI_DD", "DK_Kspipi", "cruij_sigmaR"  ],
        ["CB2DK_KSPIPI_DD", "DK_Kspipi", "gauss_sigma"],
        # ["CB2DK_KSKK_DD", "DK_Kspipi", "cruij_sigmaL"  ],
        # ["CB2DK_KSKK_DD", "DK_Kspipi", "cruij_sigmaR"  ],
        # ["CB2DK_KSKK_DD", "DK_Kspipi", "gauss_sigma"],
    ],
    # "signal_width_DK_LL": [
    #     ["CB2DK_KSPIPI_LL", "DK_Kspipi", "cruij_sigmaL"  ],
    #     ["CB2DK_KSPIPI_LL", "DK_Kspipi", "cruij_sigmaR"  ],
    #     ["CB2DK_KSPIPI_LL", "DK_Kspipi", "gauss_sigma"],
    #     ["CB2DK_KSKK_LL", "DK_Kspipi", "cruij_sigmaL"  ],
    #     ["CB2DK_KSKK_LL", "DK_Kspipi", "cruij_sigmaR"  ],
    #     ["CB2DK_KSKK_LL", "DK_Kspipi", "gauss_sigma"],
    # ],
    "signal_width_Dpi_DD": [
        ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "cruij_sigmaL"  ],
        ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "cruij_sigmaR"  ],
        ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "gauss_width"],
        # ["CB2DPI_KSKK_DD", "Dpi_Kspipi", "cruij_sigmaL"  ],
        # ["CB2DPI_KSKK_DD", "Dpi_Kspipi", "cruij_sigmaR"  ],
        # ["CB2DPI_KSKK_DD", "Dpi_Kspipi", "gauss_width"],
    ],
    # "signal_width_Dpi_LL": [
    #     ["CB2DPI_KSPIPI_LL", "Dpi_Kspipi", "cruij_sigmaL"  ],
    #     ["CB2DPI_KSPIPI_LL", "Dpi_Kspipi", "cruij_sigmaR"  ],
    #     ["CB2DPI_KSPIPI_LL", "Dpi_Kspipi", "gauss_width"],
    #     ["CB2DPI_KSKK_LL", "Dpi_Kspipi", "cruij_sigmaL"  ],
    #     ["CB2DPI_KSKK_LL", "Dpi_Kspipi", "cruij_sigmaR"  ],
    #     ["CB2DPI_KSKK_LL", "Dpi_Kspipi", "gauss_width"],
    # ],
    "Dpi_Kspipi_yield_DD": [
        ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "yield"  ],
    ],
}

BR_B2DK  = 3.63e-4
BR_B2Dpi = 4.68e-3
total_eff = {}
BDT_cut_efficiency = {}

for source in ntuples.keys():
    BDT_cut_efficiency[source] = {}
    total_eff[source] = {}
    for channel in ntuples[source].keys():
        paths = ntuples[source][channel].final_cuts_paths
        list_var = [ntuples[source][channel].variable_to_fit]
        cut = "BDT > "+str(BDT_cut)
        ntuples[source][channel].store_events(paths,list_var,cut)
        BDT_cut_efficiency[source][channel] = len(ntuples[source][channel].uproot_data[list_var[0]]) / ntuples[source][channel].final_cuts_eff["selected_events"]
        total_eff[source][channel] = ntuples[source][channel].preliminary_cuts_eff["efficiency"]*ntuples[source][channel].final_cuts_eff["efficiency"]*BDT_cut_efficiency[source][channel]
        pass
    pass



# constraining the DK yields to the Dpi one
ratio_DK_to_Dpi = {}
ratio_DK_to_Dpi["MC_Bu_D0K_KSpipi"]["CB2DK_D2KSPIPI_DD"] = BR_B2DK/BR_B2Dpi * total_eff["MC_Bu_D0pi_KSpipi"]["CB2DK_D2KSPIPI_DD"]/total_eff["MC_Bu_D0pi_KSpipi"]["CB2DPI_D2KSPIPI_DD"]
# constraining the misID Dpi to its non-misID counterpart
ratio_Dpi_misID_to_Dpi = {}
ratio_Dpi_misID_to_Dpi["CB2DK_D2KSPIPI_DD"] = total_eff["MC_Bu_D0pi_KSpipi"]["CB2Dpi_D2KSPIPI_DD"]/total_eff["MC_Bu_D0pi_KSpipi"]["CB2DK_D2KSPIPI_DD"]
# constraining the misID DK to its non-misID counterpart
ratio_DK_misID_to_DK = {}
ratio_DK_misID_to_DK["CB2DK_D2KSPIPI_DD"] = total_eff["MC_Bu_D0K_KSpipi"]["CB2DK_D2KSPIPI_DD"]/total_eff["MC_Bu_D0K_KSpipi"]["CB2Dpi_D2KSPIPI_DD"]


constrained_parameters = [
    [ ["CB2DK_KSPIPI_DD", "DK_Kspipi", "yield"], ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "yield", ratio_DK_to_Dpi["MC_Bu_D0K_KSpipi"]["CB2DK_D2KSPIPI_DD"] ] ],
    [ ["CB2DK_KSPIPI_DD", "Dpi_Kspipi_misID", "yield"], ["CB2DPI_KSPIPI_DD", "Dpi_Kspipi", "yield", ratio_Dpi_misID_to_Dpi["CB2DK_D2KSPIPI_DD"] ] ],
    [ ["CB2Dpi_KSPIPI_DD", "DK_Kspipi_misID", "yield"], ["CB2DK_KSPIPI_DD", "DK_Kspipi", "yield", ratio_DK_misID_to_DK["CB2DK_D2KSPIPI_DD"] ] ],
]

### the mean B mass of the DK and Dpi signals are shared accross samples
# i.e. variables_to_fit["CB2DK_KSPIPI_DD"]["DK_Kspipi"]["cruij_m0"]


def get_total_nll(vec_to_fit):
    variables_to_fit = dict(VARDICT["SDATA"])
    for shared_par in shared_parameters.keys(): ### loop over the input parameters
        for sharing in shared_parameters[shared_par]:
            ### loop over all parameters that should share this value
            variables_to_fit[sharing[0]][sharing[1]][sharing[2]] = vec_to_fit[shared_par]
            pass
        pass
    for const in constrained_parameters:
        variables_to_fit[const[0][0]][const[0][1]][const[0][2]] = variables_to_fit[const[1][0]][const[1][1]][const[1][2]]*const[1][3]
        pass
    total_nll = ntuples["SDATA"]["CB2DK_D2KSPIPI_DD"].get_nll(variables_to_fit["CB2DK_D2KSPIPI_DD"]) + ntuples["SDATA"]["CB2Dpi_D2KSPIPI_DD"].get_nll(variables_to_fit["CB2Dpi_D2KSPIPI_DD"])
    return total_nll


def nll(x):
    vec_to_fit = dict(shared_parameters.keys(), x)
    return get_total_nll(vec_to_fit, fixed_constraints, gaussian_constraints)
